{"componentChunkName":"component---src-templates-post-js","path":"/blog/building-llama-as-a-service/","result":{"data":{"markdownRemark":{"html":"<p>This is a walkthrough of the development process and system design engineering for the Llama as a Service. LaaS is a website and public API that can serve random Llama images. It will respond with a single image URL, or even a list.</p>\n<ul>\n<li>Visit the <a href=\"https://llama-as-a-service.netlify.app/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">LaaS website</a> for a demo</li>\n<li>View the source code on <a href=\"https://github.com/orgs/llama-as-a-service/repositories\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">GitHub</a></li>\n<li>View the walkthrough <a href=\"https://www.youtube.com/watch?v=uDQUA_JTMJk\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">YouTube video</a></li>\n</ul>\n<h3>What I Learned</h3>\n<p>For this project, there is a frontend built with <a href=\"https://reactjs.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React</a> hosted on <a href=\"https://www.netlify.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Netlify</a>, connected to the backend.</p>\n<p>I built each API with Node.js, Express, and Docker. Services connected to a NoSQL <a href=\"https://www.mongodb.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">MongoDB</a> database.</p>\n<p>Each service is in an independent repository to maintain separation of concerns. It would have been possible to build this in a monorepo, but it was good practice.</p>\n<p>Each repository uses <a href=\"https://docs.github.com/en/actions\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">GitHub Actions</a> to build, and test the code on every push. Express API was deployed to <a href=\"https://www.heroku.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Heroku</a> when the main branch was pushed.</p>\n<p>With each app containerized with <a href=\"https://www.docker.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Docker</a>, this allows it to be run on any other developer's machine also running Docker. Although I had automated deployments to Heroku without this, I decided to upload each service to a container registry.</p>\n<p>Each repository also used a GitHub Actions workflow to automatically tag and version updates and releases. It would then build and publish the most up to date Docker image, and release it to the <a href=\"https://ghcr.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">GitHub Container Registry</a>.</p>\n<p>For future use, this makes it crazy easy to deploy a Kubernetes cluster to the cloud, with a simple <code class=\"language-text\">docker pull ghcr.io/OWNER/IMAGE_NAME</code> command. However, that was beyond the scope of this project because of zero budget.</p>\n<p>To manage the environment variables, I was able to share Secrets to the GitHub Action workflows, which are encrypted, and can be shared across an entire organization (meaning multiple repos could access the variables). This allowed me to deploy my code securely to Heroku, without ever hard-coding the API keys.</p>\n<p>Another tool I used was <a href=\"https://www.artillery.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Artillery</a> for load testing on my local machine.</p>\n<p>Instead of npm, I tried using <code class=\"language-text\">yarn</code> for the package manager, and it was WAY faster in GitHub Actions even without caching enabled.</p>\n<p>Although they did not make it into production, I experimented with the <a href=\"https://www.rabbitmq.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">RabbitMQ</a> message broker, Python (Django, Flask), Kubernetes + minikube, <a href=\"https://jwt.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">JWT</a>, and <a href=\"https://www.nginx.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">NGINX</a>. This was a hobby project, but I intended to learn about microservices along the way.</p>\n<h3>Demonstration</h3>\n<p>Here is a screen shot of the <a href=\"https://llama-as-a-service.netlify.app/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">LaaS</a> website.</p>\n<p><img src=\"https://user-images.githubusercontent.com/60903378/179845930-8bd90991-42da-400b-8983-543030be0502.png\" alt=\"Frontend Screenshot\"></p>\n<p>If you would like to try out the API, simply made a GET request to the following endpoint:</p>\n<p><code class=\"language-text\">https://llama-as-a-service-images.herokuapp.com/random</code></p>\n<h3>Creating an API</h3>\n<p>First, I started with a simple API built with Node.js and Express, containerized with Docker. I set up GitHub Actions for CI to build and test it on each push. This will later connect to the database, to respond with image URLs.</p>\n<p><img src=\"https://user-images.githubusercontent.com/60903378/179846653-c04f2636-75a0-47a0-9789-d58a0cd3928e.png\" alt=\"Images API\"></p>\n<p>Although this API doesn’t NEED to scale to millions of users, it was a valuable exercise for building and scaling a system. I aimed for a minimum latency of 300ms with 200 RPS.</p>\n<h3>Image Database</h3>\n<p>With an API ready to connect to the database, it was time to choose between a NoSQL or SQL database.</p>\n<p>The answer is obvious for this use case. Let’s walk through the data we have, and the use cases.</p>\n<p>We are going to store one single table with image URLs. This could easily be done in either database, but there is one key factor. We need a way to randomly pull a list of images from the database.</p>\n<p>A SQL database makes it simple to query a random row, however, this is not horizontally scalable, and with a large data set, we are replicating the ENTIRE database to each new node.</p>\n<p>On the other hand, NoSQL databases are horizontally scalable; which leads me to Cassandra, but unfortunately it is very difficult to pull random selections from this type of NoSQL database.</p>\n<p>Finally, I settled with MongoDB, which has a built-in <code class=\"language-text\">$sample</code> method to pull from the records.</p>\n<p><img src=\"https://user-images.githubusercontent.com/60903378/179846661-8e20b67d-6d28-4971-939b-a7d347f15ee4.png\" alt=\"Mongo Database\"></p>\n<p>Once I got the MongoDB database running locally with Docker, I created a quick script to seed the database.</p>\n<p>Now it’s time to connect the API to the database.</p>\n<h3>Connecting API to the Database</h3>\n<p>Next, I used the <code class=\"language-text\">mongoose</code> Node.js API to connect to the local MongoDB.</p>\n<p>I created two endpoints; one to upload an image URL, and another to retrieve a random list of images.</p>\n<p><img src=\"https://user-images.githubusercontent.com/60903378/179846674-642b4412-3385-4b0a-9640-036225ce1423.png\" alt=\"API Database Connection\"></p>\n<h3>Endpoint Load Testing</h3>\n<p>To experiment with scaling the API, I wanted to do load testing. Keep in mind that this API does not have much logic, meaning caching, or optimizing the code's performance, will have a huge impact.</p>\n<p>I found a tool for load testing called <a href=\"https://www.artillery.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Artillery</a>. Following <a href=\"https://blog.appsignal.com/2021/11/10/a-guide-to-load-testing-nodejs-apis-with-artillery.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">this guide</a> I installed Artillery and began research for the test configuration.</p>\n<p>The API currently has the <code class=\"language-text\">/random</code> endpoint to return an image URL (a string), with very little computation. Let’s stress test this to see the current traffic limit.</p>\n<p>The random list endpoint is what we need to optimize. For the starting algorithm though, I seeded 100 image records into the database, and then pulled the ENTIRE list from the database each request. The API would then choose 25 random elements to return. Let’s benchmark how this performs with load testing.</p>\n<p>With the first run, API, the limit on the <code class=\"language-text\">/random?count=25</code> endpoint was 225 RPS over 15 seconds, with 99% of the response times were under 300ms. We can improve this.</p>\n<p><img src=\"https://user-images.githubusercontent.com/60903378/179846688-33198d9a-f9fa-4611-ba15-7161f2bf87ce.png\" alt=\"Load Testing Latency Chart\"></p>\n<p><img src=\"https://user-images.githubusercontent.com/60903378/179846696-e82bfe4e-b9b9-4114-9b59-48785b945021.png\" alt=\"Load Testing\"></p>\n<h3>Optimizing the Endpoint</h3>\n<p>We have many records of image URLs in the database. Somehow, we need to efficiently transform these into a list, pulling random selections from the database.</p>\n<p><img src=\"https://user-images.githubusercontent.com/60903378/179846759-e5654196-093c-41a2-a5aa-06029ca5c47a.png\" alt=\"Random Database Query\"></p>\n<p>Let’s optimize the query for pulling documents from the database. Using a special mongodb query, we can drastically reduce the computational load for a single request. Running locally in postman, <code class=\"language-text\">random?count=25</code> endpoint went from ~150ms for a single request, to &#x3C;50ms.</p>\n<p>This is the only code we need for this endpoint, compared to the previous 20 lines and O(n^2) space.</p>\n<p><img src=\"https://user-images.githubusercontent.com/60903378/179846772-fdcf54a1-34eb-42a1-a4cd-8b05ba783a7f.png\" alt=\"Random Query Code\"></p>\n<p>With the new query, the endpoint maintains 99% sub-300ms response time with a max of 440 RPS over 15 seconds.</p>\n<p><img src=\"https://user-images.githubusercontent.com/60903378/179846777-3518451f-33f2-4638-b4d9-c614db7d52e5.png\" alt=\"Latency Improvements Chart\"></p>\n<h3>Horizontally Scaling the API</h3>\n<p>With the containerized Node.js/Express API, I could run multiple containers, scaling to handle more traffic. Using a tool called <a href=\"https://github.com/kubernetes/minikube\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">minikube</a>, we can easily spin up a local <a href=\"https://github.com/kubernetes/kubernetes\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Kubernetes</a> cluster to horizontally scale Docker containers. It was possible to keep one shared instance of the database, and many APIs were routed with an internal Kubernetes load balancer.</p>\n<p>Horizontally scaling the API to two instances, the random endpoint maintains 99% sub-300ms response time with a max of 650 RPS over 15 seconds. Three API Instances => 99% sub-300ms response time with a max of 1000 RPS over 15 seconds. Five API Instances => 99% sub-300ms response time with a max of 1200 RPS over 15 seconds.</p>\n<p>In practice, five instances were the limit of scaling the API horizontally. Even with more instances, the traffic was never sub 300ms response time. Note, this is dependent on the hardware of my local machine, and not accounting for cross-network latency in the real world.</p>\n<p>With scaling, we can achieve higher throughput, allowing more traffic to flow, and resiliency, where a failed node can simply be replaced.</p>\n<p><img src=\"https://user-images.githubusercontent.com/60903378/179846784-c605f7e8-856a-4d8d-b1ff-e9ad16d34c33.png\" alt=\"API Horizontal Scale\"></p>\n<p>Since the image responses are intended to be random, we cannot cache the responses. It would be possible to scale the database with a slave/master system, but without a large data set, it is not worth the time to test. The bottleneck is most likely the API and connections to the database, versus MongoDB not handling read requests. It may be possible to improve the read times with a REDIS database, using in-memory caching, but that is overkill for this project.</p>\n<h3>Setting up Authentication</h3>\n<p>After playing around with load testing, I wanted to explore <a href=\"https://jwt.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">JSON Web Tokens</a> and build an API to handle authentication.</p>\n<p>This auth API will generate tokens, which will be sent back to the client as headers. The tokens headers are stored client-side (e.g. cookies, local storage), and sent to the backend each request.</p>\n<p>If we expand the backend, we could include the authentication logic in each microservice.</p>\n<p><img src=\"https://user-images.githubusercontent.com/60903378/179846797-c965ec7f-4076-4ed7-9b2e-4909004fec6e.png\" alt=\"API Coupled Services\"></p>\n<p>Not practical. Instead, we can decouple the logic into its own service as shown below:</p>\n<p><img src=\"https://user-images.githubusercontent.com/60903378/179846807-6f650b2d-165f-4345-8f93-34633b2f3cc4.png\" alt=\"API Auth Gateway\"></p>\n<h3>Creating a Gateway API</h3>\n<p>Instead of exposing the users directly to each microservice, we should route ALL traffic from the clients to the Gateway API. For this, I chose the same tech stack of Node.js/Express. Using a library, I was able to set up a proxy to the other services. In the future, this could be very useful to standardize requests to the backend, track usage, forward data to a logging microservice, talk to a message broker, and more.</p>\n<h3>Environment Variables and Configuration</h3>\n<p>Most of the system built, I needed to simplify the process for configuring the Docker containers locally, and how environment variables would be shared to each. Keep in mind, each service needed to access these in GitHub Actions as well, during deployment.</p>\n<p>I used the <code class=\"language-text\">docker-compose</code> files to easily spin up the containers locally. I used default values for the environment variables for local development, and kept the config files separated so it was easy to follow.</p>\n<p>This step was just a process of carefully writing the Docker and docker-compose files, and setting up GitHub Actions Secrets. The code could not run without having all env variables, could be hard to debug locally or lead to ambiguity for other developers.</p>\n<h3>A Simple Frontend</h3>\n<p>I would talk about building the frontend, but it is just a single page React app I built quickly. It does use a CSS library called <a href=\"https://bulma.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Bulma</a>, which is similar to tailwind and worth checking out. I did spend a day implementing a login/signup page, but this was just for the learning experience, and not what I wanted in the final product.</p>\n<h3>GitHub Actions Testing and Deployment</h3>\n<p>With most of the code written, it was time to deploy the app. This was actually a bumpy road because I was not sure how to approach this. I was keeping each component in its own repository on my personal GitHub Account, which was getting hard to keep track of.</p>\n<p>My solution was to create the <a href=\"https://github.com/llama-as-a-service\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Llama as a Service</a> GitHub Organization, which also allowed me to store organization-wide secrets that any repository could access.</p>\n<p>Using GitHub Actions, I created workflows to build and test code on every push, and deploy to main branch Heroku (and Netlify for the frontend).</p>\n<p>I also created a workflow to tag and version every update, and release the Docker image to the <a href=\"https://ghcr.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">GitHub Container Registry</a>. These packages could be private to the organization, or public. I did not end up using these published containers, but it was really dope to see everything automated.</p>\n<h3>Deploying to Production</h3>\n<p>So after deploying the gateway API, frontend, and backend, I hoped all the services would be connected in production. For some reason the <a href=\"https://www.npmjs.com/package/http-proxy-middleware\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http-proxy-middleware</a> was causing problems, and it was not worth redesigning the whole system. I was not ready to work with deploying a Kubernetes Cluster, so I did not use the GHCR Docker packages for deploying.</p>\n<p>Instead, I just stripped away the extra services that I had been working on, and stuck with a simple system to deploy. For the final product, there is the frontend deployed on Netlify, which connects to the API on Heroku, with talks to the MongoDB Atlas database (in the cloud).</p>\n<p><img src=\"https://user-images.githubusercontent.com/60903378/179846810-754daa79-2639-4550-a7dd-e0be88ef71bf.png\" alt=\"Application Architecture Diagram\"></p>\n<h3>View the Source Code</h3>\n<p>If you wish to view all of the source code for this project, you can look through each repository here:</p>\n<ul>\n<li>GitHub Organization: <a href=\"https://github.com/llama-as-a-service\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">github.com/llama-as-a-service</a></li>\n<li>All the GHCR Packages: <a href=\"https://github.com/orgs/llama-as-a-service/packages\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">github.com/orgs/llama-as-a-service/packages</a></li>\n<li>Frontend - <a href=\"https://github.com/llama-as-a-service/frontend\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">github.com/llama-as-a-service/frontend</a></li>\n<li>Images API - <a href=\"https://github.com/llama-as-a-service/images-service\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">github.com/llama-as-a-service/images-service</a></li>\n<li>Authentication API - <a href=\"https://github.com/llama-as-a-service/auth-service\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">github.com/llama-as-a-service/auth-service</a></li>\n<li>Gateway API - <a href=\"https://github.com/llama-as-a-service/gateway-service\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">github.com/llama-as-a-service/gateway-service</a></li>\n</ul>\n<p>If you want to have a repository with Node.js, Express, and Docker set up with GitHub Actions, check out the <a href=\"https://github.com/llama-as-a-service/express-docker-boilerplate\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">boilerplate repository here</a></p>\n<p>If you are interested in more projects by me, you can check out the <a href=\"https://www.spencerlepine.com/blog/manyshiba-the-worlds-greatest-twitter-bot\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ManyShiba Twitter bot</a>, or more on my website.</p>\n<hr>\n<p>Also find me here:</p>\n<ul>\n<li><a href=\"https://twitter.com/SpencerLepine\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Twitter (@spencerlepine)</a></li>\n<li><a href=\"https://github.com/spencerlepine\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">GitHub (@spencerlepine)</a></li>\n<li><a href=\"https://www.linkedin.com/in/spencer-lepine/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">LinkedIn</a></li>\n<li><a href=\"https://www.youtube.com/channel/UCBL6vAHJZqUlyJp-rcFU55Q\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">YouTube (Spencer Lepine)</a></li>\n</ul>","frontmatter":{"title":"Building Llama as a Service (LaaS)","description":"Creating the world’s first Llama as a Service, the random image API you didn't realize you needed.","date":"2022-07-13","slug":"/blog/building-llama-as-a-service","tags":["Express","Docker","MongoDB","Node.js","Heroku","GitHub Actions"],"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAC4jAAAuIwF4pT92AAACcElEQVQoz42RXWvTYBzF++G89wMIu/NGRD+BF+rVBJHBQNm6N5m70I2hmxOmshfatemaNE2aput73YhrunZtmrZJmvQnzSa78MY/HM55HngO53+eSLVRY3N3nfdbC2zurWE0DXwfHNfH8QJGro/rBaH+e+d6k1DbAxer62D1btF1iMRSx7yen2Vrd5MX80+QNIG8XiZ5KiLKCoViGSEtkRIzyKpGNpfnRDgN2R0Hd4bdW8Ojo13eLr3j5bPnPH54H0WVqDYM8mdltEKJUrUR6mK5xlm5hl6soGhnVOt1HMelZVpcdwahWa87IlLIa6ytb/Do6QwPZu5Rq5WYjuP5TICRO/4Hnj8Jk/esIRkph5YrMhoE9K5HRKZ9ZSQV88rAHnTI1y6Jp+qYrSaimmI89gh8F993CQIPxxlQKddRZI2LC4Om2UYv1Bna/o3h2IOsnMcdWWGyn8I+258P6XQ6iIrIJPAg8JkEY8APkZEUrK4b1iCIWQ7iErbl3Rmqik5CVNCLNdzRgGKlimn2uDSHOP02UrHCzr7CVcskljpAzmjYfQ+zecXsqzd8+36I2ezQ77k3hrKUI1eo0mgY+GMb4/KcVqvLudHGHdlk9CQ/DuJ0exaqriGmlfBx3xqy8eE9G+urqKqGbY2JTIJpwgJBuNL/TVbOhZ1Nf7dS1kkcfkVInlAq/yJi9Ww+fdxmbm6OxcVFotEo0egSy8srrK6usbIy5SlWw/PCwgI7X/ZoX/XD3owLg7wioGVTyEqOSMu8RkqrxI6TxGMpEvE0iZM0QkJESGYQEhLJhBTyjRbDjZq/bzrrtAeUznTk02PSySP+AErHEELQ1SubAAAAAElFTkSuQmCC","aspectRatio":1.8987341772151898,"src":"/static/6ac383c8d4d2276d275b69574208976c/8c332/thumbnail.png","srcSet":"/static/6ac383c8d4d2276d275b69574208976c/95f17/thumbnail.png 150w,\n/static/6ac383c8d4d2276d275b69574208976c/37d5a/thumbnail.png 300w,\n/static/6ac383c8d4d2276d275b69574208976c/8c332/thumbnail.png 600w,\n/static/6ac383c8d4d2276d275b69574208976c/03620/thumbnail.png 900w,\n/static/6ac383c8d4d2276d275b69574208976c/6050d/thumbnail.png 1200w","sizes":"(max-width: 600px) 100vw, 600px"}}}}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"title":"Preparing for My Amazon Front End Engineer Interview","description":"My experience and advice for the Amazon Front End Engineer interview.","slug":"/blog/preparing-for-my-amazon-front-end-engineer-interview","date":"2022-11-20T00:00:00.000Z","draft":false,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAQCBQb/xAAVAQEBAAAAAAAAAAAAAAAAAAABAP/aAAwDAQACEAMQAAABgJOjZGcI/8QAGxAAAgMAAwAAAAAAAAAAAAAAAQIAAxETIiP/2gAIAQEAAQUCONKvI8yRbDovUlx3/8QAFREBAQAAAAAAAAAAAAAAAAAAABH/2gAIAQMBAT8BR//EABYRAQEBAAAAAAAAAAAAAAAAAAARMf/aAAgBAgEBPwHFf//EABsQAAEFAQEAAAAAAAAAAAAAAAEAAhESITEQ/9oACAEBAAY/AiWjVch0c55E4qBxIRjAv//EABsQAQEBAAIDAAAAAAAAAAAAAAERACFhMXGR/9oACAEBAAE/IWIY7cgX4ejDA1+aWITPWJMHmnDu7nAb/9oADAMBAAIAAwAAABCQ/wD/xAAXEQADAQAAAAAAAAAAAAAAAAAAASER/9oACAEDAQE/EHVDR//EABYRAQEBAAAAAAAAAAAAAAAAAAAhEf/aAAgBAgEBPxCww//EAB0QAQEAAgEFAAAAAAAAAAAAAAERADEhQVFhcbH/2gAIAQEAAT8QNXiQKvrs4hg0O/i1scEkkpXhJqkzkXEpzN38Gz5m59SEAz//2Q==","aspectRatio":1.3274336283185841,"src":"/static/de7335e1fee7f9648a3e37b7ff32e00e/c3638/interview.jpg","srcSet":"/static/de7335e1fee7f9648a3e37b7ff32e00e/59538/interview.jpg 150w,\n/static/de7335e1fee7f9648a3e37b7ff32e00e/88b18/interview.jpg 300w,\n/static/de7335e1fee7f9648a3e37b7ff32e00e/c3638/interview.jpg 600w,\n/static/de7335e1fee7f9648a3e37b7ff32e00e/67507/interview.jpg 900w,\n/static/de7335e1fee7f9648a3e37b7ff32e00e/0ff54/interview.jpg 1200w,\n/static/de7335e1fee7f9648a3e37b7ff32e00e/5f7bf/interview.jpg 4032w","sizes":"(max-width: 600px) 100vw, 600px"}}}}}},{"node":{"frontmatter":{"title":"TypeScript Development Set Up for VSCode","description":"Follow steps to set up VSCode for a TypeScript project, including auto-compile and format-on-save.","slug":"/blog/typescript-development-set-up-for-vscode","date":"2022-10-24T00:00:00.000Z","draft":false,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAC4jAAAuIwF4pT92AAACdklEQVQoz22TWUgVURzGD6alhopZ6UtBYRFIC/TgU2RQL5EF4UJUTwaJgZgtWhIhqL20caWCLGwRsZCIMKtrYJJe18powa3FreyqM3fxzsxd5v5iZhIUOvDjf+BwPr4Pvr/wuDQM3C4NSVZNZGNK1t0la3jcGi5ZMQkFgDB4PQFkyWe+mbg0vG4NMS+mePygBRfjDxJWAqaQpoRBh6bnLdy8dRePrKCHwC2rzJsyEC5ZRfP6+fjTQ07dMFkPh8muGyanboTMe0NU2McJKTpfv4yQf6KQpOQUYmJj2ZN5kJfPmvF5g6ao22UJCyOe4aK+14ko7EQUd1uc6kYUdJBmG2Tw8xCpaVtYGhNDSlIicbkliOoPRGTkUlN9g3AY5FkrvpAlFd0X4PG7aURpL0vK+hDnei3OdpNRO0pnWwcJG7ex/Nh1oo9WEpV3hWV3hhDHbVwsPolxpJm5xQ4f9U0jSnooeTFOTY+TM83jlL0aY1/dGF2OPpLXbSCisB5hGyMhfT+xZU8QeTaqzpf+X7Dx/TSiqIudtwcofz1pztrePxxunORNq4P4Nams2L6bxPRMIkrbiKwPIbLLubDQ4XxkQ9CMfMLB+sufONTwjdWV/Vxrn6Lg6Sj9w062ZuUTGZ9IclwUKzfvQGRXEbvrCPeb3qL7QZYUy6FRGZ9H48fvOSrt41TaJ7jUMoGt7RdXWyd50DWFrgQZk3RO19pZlb6X6LWbOFBUgWPAiV81qmOJeRb20Gf0UA2CGjDRFQurhyqKWzUL3T44Q0Pnd/whCClBs6OLim126B/mdkgq8oJp4DY3RkWa9eH3+tHVEC7JZ8Y0zMz/NyL/BbsBxJJgX6exAAAAAElFTkSuQmCC","aspectRatio":1.8987341772151898,"src":"/static/8c71c4537c0d511deba68fa72f815165/8c332/thumbnail.png","srcSet":"/static/8c71c4537c0d511deba68fa72f815165/95f17/thumbnail.png 150w,\n/static/8c71c4537c0d511deba68fa72f815165/37d5a/thumbnail.png 300w,\n/static/8c71c4537c0d511deba68fa72f815165/8c332/thumbnail.png 600w,\n/static/8c71c4537c0d511deba68fa72f815165/03620/thumbnail.png 900w,\n/static/8c71c4537c0d511deba68fa72f815165/6050d/thumbnail.png 1200w","sizes":"(max-width: 600px) 100vw, 600px"}}}}}},{"node":{"frontmatter":{"title":"Quickly Open GitHub Repo in Browser From Terminal","description":"Create custom Git commands to open the repository web page in the browser.","slug":"/blog/quickly-open-github-repo-in-browser-from-terminal","date":"2022-10-22T00:00:00.000Z","draft":false,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAC4jAAAuIwF4pT92AAAChUlEQVQoz12TXUtUURSG57/0IwLpIuquEPugi65CGzKzRgjzo8wvytC0tBCVysAmUysJEqqLClJJzdIxsAIvwtJ0Ruecs8/H2ufM5BNnRina8LAXi7Xfvdjr3RHb0ihTowwP2/BysWUKyhQsw8vFYY2rNE6IpbHNvygjj2XkdSIqJyhY7m8sIZd07Syeu4V45GLTEH4lhfWUkDKEDUswlGDZgu0Irit47o6gIVjhwZlpvOdPUO4WaytJErPTvHnxjI21VT4kNDXXVqjuTVPVFlDXHtB4M6C5O6Clz6epR/NwzMO2hIgSsOcTBEd3E1wowRobpft2E/23Grl09giJj+PMzwgni9eJViua97tcLhJqosLFQqG2wKV8l0ln1ECpUNDyUZsO9LZCZyOpb0vcuFLB6MNePkyOs7L8nbkZxZniTcrPuXQcEFoPaJpKhLZjKdoOr1JbkKTvdBoVdhg+rKkyvJ+aY3F+EX8LNn4lETfDzvo0lSYWM4jFhM5CTeshTUOlUFctNJSmqC/+Qk/FZm4WEc/JsPpzg7bzZTztv8url28ZHhplMD7CYPwxE+MTLMw6VJyyqKjWdBZpOvYHNJc4tJxWtJywqN2zTG9pCqXCoZiC42TpeTDMu+kEk+PT3Ltzn8H4MF03u3k8MsLCrE151KbsvKb9oKZ5n6bmuE1d1OJSscm5vT/oOrFO6JhIOGpb+SytOSwnHQKBTADZDGQDYAu+fra5dd2jp0sYqhIeVbrE6x3i9YrBqyYDTQavBwzssMMdY4vy8ZSf85yZ9jANL7+nvZyhPVsjriC+4Gc0QUaTyfoEQX7Xvr/tw/BnhCKhH/9lO79D/iKNuRkiGP8R5sK6P0Ka9D+KYDXBAAAAAElFTkSuQmCC","aspectRatio":1.8987341772151898,"src":"/static/72552018b8aa23d4d2f519fbf005414b/8c332/thumbnail.png","srcSet":"/static/72552018b8aa23d4d2f519fbf005414b/95f17/thumbnail.png 150w,\n/static/72552018b8aa23d4d2f519fbf005414b/37d5a/thumbnail.png 300w,\n/static/72552018b8aa23d4d2f519fbf005414b/8c332/thumbnail.png 600w,\n/static/72552018b8aa23d4d2f519fbf005414b/03620/thumbnail.png 900w,\n/static/72552018b8aa23d4d2f519fbf005414b/6050d/thumbnail.png 1200w","sizes":"(max-width: 600px) 100vw, 600px"}}}}}},{"node":{"frontmatter":{"title":"Building Llama as a Service (LaaS)","description":"Creating the world’s first Llama as a Service, the random image API you didn't realize you needed.","slug":"/blog/building-llama-as-a-service","date":"2022-07-13","draft":false,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAC4jAAAuIwF4pT92AAACcElEQVQoz42RXWvTYBzF++G89wMIu/NGRD+BF+rVBJHBQNm6N5m70I2hmxOmshfatemaNE2aput73YhrunZtmrZJmvQnzSa78MY/HM55HngO53+eSLVRY3N3nfdbC2zurWE0DXwfHNfH8QJGro/rBaH+e+d6k1DbAxer62D1btF1iMRSx7yen2Vrd5MX80+QNIG8XiZ5KiLKCoViGSEtkRIzyKpGNpfnRDgN2R0Hd4bdW8Ojo13eLr3j5bPnPH54H0WVqDYM8mdltEKJUrUR6mK5xlm5hl6soGhnVOt1HMelZVpcdwahWa87IlLIa6ytb/Do6QwPZu5Rq5WYjuP5TICRO/4Hnj8Jk/esIRkph5YrMhoE9K5HRKZ9ZSQV88rAHnTI1y6Jp+qYrSaimmI89gh8F993CQIPxxlQKddRZI2LC4Om2UYv1Bna/o3h2IOsnMcdWWGyn8I+258P6XQ6iIrIJPAg8JkEY8APkZEUrK4b1iCIWQ7iErbl3Rmqik5CVNCLNdzRgGKlimn2uDSHOP02UrHCzr7CVcskljpAzmjYfQ+zecXsqzd8+36I2ezQ77k3hrKUI1eo0mgY+GMb4/KcVqvLudHGHdlk9CQ/DuJ0exaqriGmlfBx3xqy8eE9G+urqKqGbY2JTIJpwgJBuNL/TVbOhZ1Nf7dS1kkcfkVInlAq/yJi9Ww+fdxmbm6OxcVFotEo0egSy8srrK6usbIy5SlWw/PCwgI7X/ZoX/XD3owLg7wioGVTyEqOSMu8RkqrxI6TxGMpEvE0iZM0QkJESGYQEhLJhBTyjRbDjZq/bzrrtAeUznTk02PSySP+AErHEELQ1SubAAAAAElFTkSuQmCC","aspectRatio":1.8987341772151898,"src":"/static/6ac383c8d4d2276d275b69574208976c/8c332/thumbnail.png","srcSet":"/static/6ac383c8d4d2276d275b69574208976c/95f17/thumbnail.png 150w,\n/static/6ac383c8d4d2276d275b69574208976c/37d5a/thumbnail.png 300w,\n/static/6ac383c8d4d2276d275b69574208976c/8c332/thumbnail.png 600w,\n/static/6ac383c8d4d2276d275b69574208976c/03620/thumbnail.png 900w,\n/static/6ac383c8d4d2276d275b69574208976c/6050d/thumbnail.png 1200w","sizes":"(max-width: 600px) 100vw, 600px"}}}}}}]}},"pageContext":{}},"staticQueryHashes":["1994492073"]}